# Malbolge Programming Language: A Beginner's Guide

## Table of Contents

1. [What is Malbolge?](#what-is-malbolge)
1. [History and Design Philosophy](#history-and-design-philosophy)
1. [Why Learn Malbolge?](#why-learn-malbolge)
1. [How Malbolge Works](#how-malbolge-works)
1. [The Eight Instructions](#the-eight-instructions)
1. [Memory Model and Ternary Arithmetic](#memory-model-and-ternary-arithmetic)
1. [Example Programs](#example-programs)
1. [Understanding Program Generation](#understanding-program-generation)
1. [Resources and Further Reading](#resources-and-further-reading)

______________________________________________________________________

## What is Malbolge?

**Malbolge** is an esoteric programming language designed in 1998 by Ben Olmstead with one explicit goal: **to be as difficult to program in as possible**. The name comes from **Malebolge**, the eighth circle of hell in Dante's *Inferno*, which is reserved for fraudsters and deceivers.

Unlike practical programming languages designed for productivity, Malbolge is an artistic statement about complexity, featuring:

- Self-modifying code (instructions change after execution)
- Base-3 (ternary) arithmetic instead of binary
- A "crazy operation" with counter-intuitive behavior
- Encrypted instructions that make hand-writing programs nearly impossible

**Key Fact**: The first "Hello World" program in Malbolge wasn't written by a human—it was discovered by a Lisp program using beam search algorithms after two years of attempts!

______________________________________________________________________

## History and Design Philosophy

### Timeline

- **1998**: Ben Olmstead creates Malbolge as an intentionally difficult language
- **2000**: First working program generated by Andrew Cooke's automated search
- **2005**: First non-trivial program (99 Bottles of Beer) by Hisashi Iizawa
- **Present**: Malbolge programs are primarily generated by algorithms, not hand-written

### Design Goals

Olmstead succeeded in creating a language where:

1. **No human could write programs directly** - The instruction set is too complex
1. **Self-modification is mandatory** - Code encrypts itself after each instruction
1. **Addressing is non-intuitive** - Ternary arithmetic with rotating digits
1. **Debugging is nearly impossible** - State changes are difficult to predict

This makes Malbolge a fascinating case study in computational complexity and automated program synthesis.

______________________________________________________________________

## Why Learn Malbolge?

While you'll never use Malbolge in production, studying it offers unique insights:

### Educational Value

- **Automated Program Generation**: Since humans can't write Malbolge directly, you learn algorithms that generate code
- **Search Space Exploration**: Understanding how to find valid programs teaches breadth-first search, pruning, and heuristics
- **Ternary Computing**: Rare exposure to base-3 arithmetic and non-binary logic
- **Compiler Construction**: Building generators teaches you about intermediate representations and optimization

### This Project's Purpose

**MalbolgeGenerator** solves the core challenge: "Given a target output string, automatically synthesize a Malbolge program that prints it." This is a constrained optimization problem with applications in:

- Code synthesis
- Constraint solving
- Search algorithm optimization
- Esoteric programming language research

______________________________________________________________________

## How Malbolge Works

### The Virtual Machine

Malbolge runs on a virtual machine with:

- **Memory (Tape)**: Up to 59,049 cells (3^10 in ternary)
- **Three Registers**:
  - **A** (Accumulator): Stores computation results
  - **C** (Code Pointer): Points to the next instruction
  - **D** (Data Pointer): Points to the current data cell

### Execution Cycle

Every instruction follows this pattern:

```
1. Calculate actual instruction: opcode = (C + memory[C]) mod 94
2. Execute the instruction (see table below)
3. Encrypt the memory cell: memory[C] = encrypt(memory[C])
4. Increment pointers: C++, D++
5. Repeat until 'v' (halt) instruction
```

The encryption step (step 3) is what makes Malbolge self-modifying—code literally changes as it runs!

______________________________________________________________________

## The Eight Instructions

Malbolge has only **8 valid instructions**. When you calculate `(C + memory[C]) mod 94`, the result maps to one of these operations:

| Opcode | Name      | Effect                                    | Description                                                     |
| ------ | --------- | ----------------------------------------- | --------------------------------------------------------------- |
| **j**  | Jump      | `C = memory[D]`                           | Set code pointer to value at data pointer (indirect jump)       |
| **i**  | Indirect  | `D = memory[D]`                           | Set data pointer to value at data pointer (indirect addressing) |
| **\*** | Rotate    | `A = memory[D] = rotate_right(memory[D])` | Rotate memory cell right in ternary, store in A                 |
| **p**  | Operation | `A = memory[D] = crazy(A, memory[D])`     | Apply "crazy operation" (ternary logic gate)                    |
| **\<** | Output    | `print(A mod 256)`                        | Output accumulator as ASCII character                           |
| **/**  | Input     | `A = read_char()`                         | Read one character from input into A                            |
| **o**  | No-op     | *continue*                                | Do nothing (except increment C and D)                           |
| **v**  | Halt      | *stop*                                    | End program execution                                           |

### The "Crazy Operation"

The **crazy operation** (instruction `p`) is a custom ternary truth table that combines two ternary digits. It's designed to be non-intuitive and make computation extremely difficult. Here's a simplified view:

```
For each trit (ternary digit) in positions 0-9:
  result[i] = CRAZY_TABLE[A[i]][memory[D][i]]
```

The table is specially crafted to avoid useful patterns, making predictable computation nearly impossible.

______________________________________________________________________

## Memory Model and Ternary Arithmetic

### Why Ternary (Base-3)?

Instead of bits (0, 1), Malbolge uses **trits** (0, 1, 2). Each memory cell holds a 10-trit number:

```
Decimal: 0 to 59,048
Ternary: 0000000000 to 2222222222 (base-3)
```

### Ternary Rotation

When you execute the `*` instruction, the memory cell rotates **right** in ternary:

```
Example:
  Before: 1201 (base-3) = 46 (base-10)
  After:  1120 (base-3) = 42 (base-10)  [rightmost digit moves left]
```

This operation is reversible, which is crucial for generating programs.

### Memory Encryption

After executing an instruction at address C, the cell is encrypted:

```python
encrypted = ENCRYPTION_TABLE[(original + position) mod 94]
```

This prevents simple loops and forces creative programming techniques.

______________________________________________________________________

## Example Programs

### Example 1: Simplest Program (Halt)

```malbolge
v
```

**Opcodes**: `v`
**Output**: *(none)*
**Explanation**: Just halt immediately. This is the only program you can hand-write confidently!

______________________________________________________________________

### Example 2: Hello World (Generated)

```malbolge
(=<`#9]~6ZY32Vx/4Rs+0No-&Jk)"Fh}|Bcy?`=*z]Kw%oG4UUS0/@-ejc(:'8dc
```

**Output**: `Hello World!`
**Explanation**: This 62-character program was generated by search algorithms. The ASCII characters map to opcodes that manipulate memory to output each character of "Hello World!".

**Try it yourself**:

```bash
python -m malbolge.cli run --ascii "(=<\`#9]~6ZY32Vx/4Rs+0No-&Jk)\"Fh}|Bcy?\`=*z]Kw%oG4UUS0/@-ejc(:'8dc"
```

______________________________________________________________________

### Example 3: Print "Hi" (Generated with This Tool)

```bash
# Generate the program
python -m malbolge.cli generate --text "Hi" --seed 42

# Output (opcodes):
iooooo...o**oo*ooppo*oooo**ppoppo**p<pooo*po**ppoop*o*popo*p***pp***o**ooopoo***pppopp*pooooopop*oopopoopopp*o**o*po***pppopop<v

# The ASCII representation is:
bCBA@?>=<;:9876543210/.-,+*)('&%$#"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?!~<;{98105u3210po'&+$#(hg}C{"!~`v{]\rqvunVrTjohmOeMLKa`HGFbDC_^]V[Z<;:PONSLK3INMLKJCHA)ED=B;@?8=65{9yx6v.3srq)(',%*#G4
```

**Breakdown of what happens**:

1. `i` + many `o` instructions: Initialize memory and set up state
1. `**oo*ooppo...`: Series of operations and rotations to create 'H' (72)
1. `<`: Output 'H'
1. More operations to create 'i' (105)
1. `<`: Output 'i'
1. `v`: Halt

______________________________________________________________________

### Example 4: Understanding a Simple Generated Program

Let's trace through a minimal program that outputs 'A' (ASCII 65):

```
Initial state:
  A = 0, C = 0, D = 0
  memory[0] = some_initial_value

Instruction sequence (simplified):
  1. Set up memory with rotations (*)
  2. Apply crazy operations (p) to reach A=65
  3. Output (<)
  4. Halt (v)
```

The generator explores thousands of combinations of `o`, `*`, and `p` instructions until it finds a sequence that produces A=65, then inserts `<` to output it.

______________________________________________________________________

## Understanding Program Generation

### Why We Can't Write Malbolge by Hand

1. **Encryption**: After each instruction, memory changes unpredictably
1. **Complex Addressing**: Calculating `(C + memory[C]) mod 94` mentally is impractical
1. **Crazy Operation**: No intuitive mapping from inputs to outputs
1. **State Explosion**: Each instruction creates branching possibilities

### How MalbolgeGenerator Works

This project uses a **deterministic breadth-first search** with optimization:

```
Algorithm:
  1. Start with bootstrap sequence: 'i' + 99 'o' instructions
  2. For each character in target string:
     a. Try appending each opcode ('o', 'p', '*')
     b. Execute program up to that point
     c. Keep only branches where output matches target prefix
     d. Prune branches with wrong output (dead ends)
     e. Cache machine states to avoid re-execution
  3. Append 'v' (halt) when target is reached
```

**Key Optimizations**:

- **Caching**: Reuse interpreter snapshots (avoid re-running 1000s of steps)
- **Pruning**: Discard branches that output wrong characters immediately
- **Depth Limits**: Randomize after exploring N levels to avoid infinite search

### Statistics from Real Generation

When generating "Hi":

```
Evaluations: 6,776 program candidates tested
Cache hits: 0 (first time, nothing cached yet)
Pruned: 6,755 dead branches eliminated
Duration: ~49ms
```

This shows the generator tested thousands of possibilities but eliminated 99.7% as dead ends!

______________________________________________________________________

## Resources and Further Reading

### Online Interpreters

Test Malbolge programs online:

- [Try It Online (TIO)](https://tio.run/#malbolge) - Run Malbolge in your browser
- [Tutorialspoint Executor](https://www.tutorialspoint.com/execute_malbolge_online.php)

### Tutorials and Documentation

- [Malbolge Tutorial by Matthias Ernst](http://www.matthias-ernst.eu/malbolge/tutorial/01/learning-malbolge.html) - Step-by-step cat program guide
- [Lou Scheffer's Programming in Malbolge](http://www.lscheffer.com/malbolge.shtml) - Deep technical analysis (Note: SSL certificate may be expired)
- [Esolang Wiki: Malbolge](https://esolangs.org/wiki/Malbolge) - Comprehensive reference

### Assembly Languages for Malbolge

- **HeLL**: Low-level assembly with labels and mnemonics
- **LAL**: Alternative assembly language
- **LMAO**: Assembler tool that generates Malbolge from HeLL code
  - GitHub: [esoteric-programmer/LMAO](https://github.com/esoteric-programmer/LMAO)

### Academic Papers

- [Introduction to Esoteric Language Malbolge](https://www.trs.cm.is.nagoya-u.ac.jp/projects/Malbolge/papers/JVSE2010-Malbolge.pdf) by Masahiko Sakai (2010)

### Working Example Programs

Classic Malbolge programs (all generated algorithmically):

- **Hello World**: 62 characters
- **99 Bottles of Beer**: First non-trivial program (2005)
- **Cat Program**: Reads input and echoes it back
- **Digital Root Calculator**: First arithmetic program

### This Project's Resources

Within this repository:

- `README.md`: Quickstart and API overview
- `docs/TUTORIAL.md`: CLI workflows and troubleshooting
- `examples/analyze_program.py`: Inspect generated programs
- `notebooks/Malbolge_Advanced_Tour.ipynb`: Interactive walkthrough

______________________________________________________________________

## Quick Start with This Project

### 1. Generate Your First Program

```bash
# Generate a program that prints "Hello"
python -m malbolge.cli generate --text "Hello" --seed 42
```

### 2. Run an Existing Program

```bash
# Run using opcodes
python -m malbolge.cli run --opcodes "v"

# Run using ASCII Malbolge code
python -m malbolge.cli run --ascii "(=<\`#9]~6ZY32Vx/4Rs+0No-&Jk)\"Fh}|Bcy?\`=*z]Kw%oG4UUS0/@-ejc(:'8dc"
```

### 3. Analyze a Generated Program

```bash
# See detailed execution statistics
python examples/analyze_program.py --text "Hi" --seed 42
```

### 4. Experiment in Python

```python
from malbolge import ProgramGenerator, MalbolgeInterpreter

# Generate a program
generator = ProgramGenerator()
result = generator.generate_for_string("ABC")

print(f"Opcodes: {result.opcodes}")
print(f"Output: {result.machine_output}")
print(f"Stats: {result.stats}")

# Run it through the interpreter
interpreter = MalbolgeInterpreter()
execution = interpreter.execute(result.opcodes)
print(f"Verified output: {execution.output}")
```

______________________________________________________________________

## Conclusion

Malbolge represents the extreme limit of programming language complexity. While impractical for real work, it teaches valuable lessons about:

- **Automated code generation** and synthesis
- **Search algorithms** for constrained spaces
- **Alternative computing models** (ternary vs. binary)
- **Self-modifying code** and its implications

With **MalbolgeGenerator**, you can explore this fascinating language without the impossible task of hand-writing programs. Use it to learn about search algorithms, experiment with esoteric computing, or just appreciate the artistry of intentional complexity!

______________________________________________________________________

**Next Steps**:

- Read `docs/TUTORIAL.md` for detailed CLI workflows
- Try `examples/analyze_program.py` to understand program structure
- Open `notebooks/Malbolge_Advanced_Tour.ipynb` for interactive exploration
- Experiment with different `--seed` values to see how generation varies
